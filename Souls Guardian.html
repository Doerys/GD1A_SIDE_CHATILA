<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" /><title>Souls Guardian</title>

        <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

        <style type="text/css"> body { margin: 0; }</style>>
    </head>
    <body>
        <script type="text/javascript">
            
            var config = {
                type: Phaser.AUTO,

                // Dimensions de l'espace de la fenêtre alloué au jeu
                width: 1200, height: 750,
                
                // Physique du jeu (gravité)
                physics: {
                    default: 'arcade',
                    arcade: {
                    gravity: { y: 300 },
                    debug: true
                    }},

                input:{gamepad:true},
                scene: {preload: preload, create: create, update: update }
                };

                new Phaser.Game(config);

// VARIABLES
let platforms;
let player;
let espritsLayer;

let cursors;

let health = 4;
let frameInvincible = 0;
let invincibleOn = false;

let gameOver = false;

let jumpMax = 1;
let jumpLeft = jumpMax;
let coolDownJump = false;
let commandesLocked = false;
let wallJumpLocked = false;

let esprits;
let textScore;
let espritScore = 0;

let speedMoveX = 150;
let speedMoveY = 210;
let playerInertie = 0;

let wallIce = false;

var controller = false; //manette

// FONCTION PRELOAD - précharger en mémoire les éléments de notre jeu (assets)
function preload(){

    // Player
    this.load.spritesheet('perso','assets/perso.png',
        { frameWidth: 32, frameHeight: 48 });

    // BACKGROUND
    this.load.image('background', 'assets/background.png');
    this.load.image('secondPlan', 'assets/secondPlan.png'); 

    // UI
        // UI - LIFE
            this.load.image('lifeFull',"assets/Life_Full.png");
            this.load.image('life1',"assets/Life_Hurt_1.png");
            this.load.image('life2',"assets/Life_Hurt_2.png");
            this.load.image('life3',"assets/Life_Hurt_3.png");
            this.load.image('lifeDead',"assets/Life_Dead.png");

        // UI - ESPRITS
            this.load.image('fond_score', 'assets/fond_chiffre.png');
            this.load.image('espritUI', "assets/esprit.png");

    // PLATEFORMES
        this.load.tilemapTiledJSON("carte", "assets/map.json");
        this.load.image("Phaser_tuilesdejeu", "assets/tuilesJeu.png");

    // OBSTACLES
        this.load.image('cristauxImage', 'assets/cristaux.png');

        this.load.image('picsBasImage', 'assets/picsBas.png');
        this.load.image('picsHautImage', 'assets/picsHaut.png');
        this.load.image('picsDroiteImage', 'assets/picsDroite.png');
        this.load.image('picsGaucheImage', 'assets/picsGauche.png');

        this.load.image('laveImage', 'assets/lava.png');
        
        this.load.image('picsGlaceBasImage', 'assets/picsGlaceBas.png');        
        this.load.image('picsGlaceHautImage', 'assets/picsGlaceHaut.png');
        this.load.image('picsGlaceDroiteImage', 'assets/picsGlaceDroite.png');
        this.load.image('picsGlaceGaucheImage', 'assets/picsGlaceGauche.png');

    // MOBS
        // Préchargement apparence monstre
            this.load.image('monsterRightApparence', 'assets/monstre_right.png');
            this.load.image('monsterLeftApparence', 'assets/monstre_left.png');

    // PICK UPS OBJECTS
    this.load.image('espritCollectible', 'assets/esprit_in_game.png');
    this.load.image("powerUpImage", 'assets/powerUp.png');

    // ----------------------------------------------------- FIN FONCTION PRELOAD ----------------------------------------------

}

// FONCTION CREATE - Gère le stade initial du jeu
function create(){

    // ARRIERE PLAN

        // ARRIERE PLAN - BACKGROUND
        this.backgroundParallax = this.add.tileSprite(0, 0, 1600, 1600, "background");
        this.backgroundParallax.setOrigin(0, 0);
        this.backgroundParallax.setScrollFactor(0.5, 1);

        // ARRIERE PLAN - SECOND PLAN
        this.sndPlanParallax = this.add.tileSprite(0, 0, 1600, 1600, "secondPlan");
        this.sndPlanParallax.setOrigin(0, 0);
        this.sndPlanParallax.setScrollFactor(0.9, 1);

    // PLAYER
        player = this.physics.add.sprite(50, 1400, 'perso');

    // MAP DE TILED
        // TILEMAP    
            const carteDuNiveau = this.add.tilemap("carte");

        // TILESET
            const tileset = carteDuNiveau.addTilesetImage("tuiles_de_jeu","Phaser_tuilesdejeu",);

            // PLATEFORMES NORMALES []
                const plateformes = carteDuNiveau.createLayer("plateformes",tileset);

                // collisions
                plateformes.setCollisionByProperty({estSolide: true });
                this.physics.add.collider(player, plateformes, normalPlatsProperties, null, this);


            // PLATEFORMES NEIGE **
                const plateformesNeige = carteDuNiveau.createLayer("plateformesNeige",tileset);

                // collisions
                plateformesNeige.setCollisionByProperty({estNeige : true });
                this.physics.add.collider(player, plateformesNeige, neigePlatsProperties, null, this);

            // PLATEFORMES GLACE __
                const plateformesGlace = carteDuNiveau.createLayer("plateformesGlace",tileset);

                // collisions
                plateformesGlace.setCollisionByProperty({estGlace : true });
                this.physics.add.collider(player, plateformesGlace, glacePlatsProperties, null, this);

        // OBJECTS
        
            // PICK-UP-OBJECTS 
                
                //ESPRITS
                    //récupération
                    esprits = this.physics.add.staticGroup();
                    espritsLayer = carteDuNiveau.getObjectLayer('espritsLayer')['objects'];
                    
                    // creation
                    espritsLayer.forEach(object => {
                    let obj = esprits.create(object.x + 16, object.y -16, 'espritCollectible');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.overlap(player, esprits, collectEsprits, null, this);

                // POWER UP - DOUBLE JUMP

                powerUp = this.physics.add.staticGroup();
                powerUpLayer = carteDuNiveau.getObjectLayer('powerUpLayer')['objects'];
                
                // creation
                powerUpLayer.forEach(object => {
                let obj = powerUp.create(object.x + 16, object.y -16, 'powerUpImage');
                    obj.setScale(object.width/32, object.height/32);
                    obj.body.width = object.width;
                    obj.body.height = object.height;
                });

                // collisions
                this.physics.add.overlap(player, powerUp, unlockDoubleJump, null, this);

            // OBSTACLES
                //CRISTAUX
                    //récupération
                    cristaux = this.physics.add.staticGroup();
                    cristauxLayer = carteDuNiveau.getObjectLayer('cristauxLayer')['objects'];
                
                    // creation
                    cristauxLayer.forEach(object => {
                        let obj = cristaux.create(object.x + 16, object.y -16, 'cristauxImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                
                    // collisions
                    this.physics.add.overlap(player, cristaux, killPlayer, null, this);

                // PICS BAS

                    //récupération
                    picsBas = this.physics.add.staticGroup();
                    picsBasLayer = carteDuNiveau.getObjectLayer('picsBasLayer')['objects'];
                    
                        // creation
                        picsBasLayer.forEach(object => {
                            let obj = picsBas.create(object.x + 16, object.y -16, 'picsBasImage');
                            obj.setScale(object.width/32, object.height/32);
                            obj.body.width = object.width;
                            obj.body.height = object.height;
                        });
                    
                        // collisions
                        this.physics.add.overlap(player, picsBas, killPlayer, null, this);
        
                // PICS HAUT

                    //récupération
                    picsHaut = this.physics.add.staticGroup();
                    picsHautLayer = carteDuNiveau.getObjectLayer('picsHautLayer')['objects'];
                    
                    // creation
                    picsHautLayer.forEach(object => {
                        let obj = picsHaut.create(object.x + 16, object.y -16, 'picsHautImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsHaut, killPlayer, null, this);

                // PICS DROITE

                    //récupération
                    picsDroite = this.physics.add.staticGroup();
                    picsDroiteLayer = carteDuNiveau.getObjectLayer('picsDroiteLayer')['objects'];
                    
                    // creation
                    picsDroiteLayer.forEach(object => {
                        let obj = picsDroite.create(object.x + 16, object.y -16, 'picsDroiteImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsDroite, killPlayer, null, this);

                // PICS GAUCHE

                    //récupération
                    picsGauche = this.physics.add.staticGroup();
                    picsGaucheLayer = carteDuNiveau.getObjectLayer('picsGaucheLayer')['objects'];
                    
                    // creation
                    picsGaucheLayer.forEach(object => {
                        let obj = picsGauche.create(object.x + 16, object.y -16, 'picsGaucheImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGauche, killPlayer, null, this);

                // LAVE

                    //récupération
                    lave = this.physics.add.staticGroup();
                    laveLayer = carteDuNiveau.getObjectLayer('laveLayer')['objects'];
                    
                    // creation
                    laveLayer.forEach(object => {
                        let obj = lave.create(object.x + 16, object.y -16, 'laveImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, lave, killPlayer, null, this);

                // PICS GLACE BAS

                    //récupération
                    picsGlaceBas = this.physics.add.staticGroup();
                    picsGlaceBasLayer = carteDuNiveau.getObjectLayer('picsGlaceBasLayer')['objects'];
                    
                    // creation
                    picsGlaceBasLayer.forEach(object => {
                        let obj = picsGlaceBas.create(object.x + 16, object.y -16, 'picsGlaceBasImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceBas, killPlayer, null, this);

                // PICS GLACE DROITE

                    //récupération
                    picsGlaceDroite = this.physics.add.staticGroup();
                    picsGlaceDroiteLayer = carteDuNiveau.getObjectLayer('picsGlaceDroiteLayer')['objects'];
                    
                    // creation
                    picsGlaceDroiteLayer.forEach(object => {
                        let obj = picsGlaceDroite.create(object.x + 16, object.y -16, 'picsGlaceDroiteImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceDroite, killPlayer, null, this);

                // PICS GLACE GAUCHE

                    //récupération
                    picsGlaceGauche = this.physics.add.staticGroup();
                    picsGlaceGaucheLayer = carteDuNiveau.getObjectLayer('picsGlaceGaucheLayer')['objects'];
                    
                    // creation
                    picsGlaceGaucheLayer.forEach(object => {
                        let obj = picsGlaceGauche.create(object.x + 16, object.y -16, 'picsGlaceGaucheImage');monstresRight
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceGauche, killPlayer, null, this);

            //MOBS 
                // MONSTRES VERS DROITE
                    // récupération
                    monstresRight = this.physics.add.group();
                    monstresRightLayer = carteDuNiveau.getObjectLayer('monstresRightLayer');
                    
                    // creation
                    monstresRightLayer.objects.forEach( monstresRightLayer => {
                        const MmonstresRightLayer = monstresRight.create( monstresRightLayer.x + 16, monstresRightLayer.y + 16, "monsterRightApparence").body.setAllowGravity(false).setBounce(1);
                    });
                    monstresRight.setVelocity(0, 100);

                    // collisions
                    this.physics.add.overlap(player, monstresRight, toucheMobDroite, null, this);

                //MONSTRES VERS GAUCHE
                    // récupération
                    monstresLeft = this.physics.add.group();
                    monstresLeftLayer = carteDuNiveau.getObjectLayer('monstresLeftLayer');
                    
                    // creation
                    monstresLeftLayer.objects.forEach( monstresLeftLayer => {
                        const MMonstresLeftLayer = monstresLeft.create( monstresLeftLayer.x + 16, monstresLeftLayer.y + 16, "monsterLeftApparence").body.setAllowGravity(false).setBounce(1);
                    });
                    monstresLeft.setVelocity(0, 100);

                    // collisions
                    this.physics.add.overlap(player, monstresLeft, toucheMobGauche, null, this);

                //BORDURES MONSTRES RIGHT (délimitant les déplacements des Ennemis de droite)
                    // récupération
                    limitesMonstresRight = this.physics.add.group();
                    limitesMonstresRightLayer = carteDuNiveau.getObjectLayer('limitesMonstresRightLayer');
                    
                    // création
                    limitesMonstresRightLayer.objects.forEach( limitesMonstresRightLayer => {
                        const LimitesMonstresRightLayer = limitesMonstresRight.create( limitesMonstresRightLayer.x + 16, limitesMonstresRightLayer.y +16).body.setAllowGravity(false).setImmovable(true);
                    });

                    // collisions
                    this.physics.add.collider(monstresLeft, limitesMonstresRight);

                //BORDURES MONSTRES LEFT (délimitant les déplacements des Ennemis de gauche)
                    // récupération
                    limitesMonstresLeft = this.physics.add.group();
                    limitesMonstresLeftLayer = carteDuNiveau.getObjectLayer('limitesMonstresLeftLayer');
                    
                    // création
                    limitesMonstresLeftLayer.objects.forEach( limitesMonstresLeftLayer => {
                        const LimitesMonstresLeftLayer = limitesMonstresLeft.create( limitesMonstresLeftLayer.x + 16, limitesMonstresLeftLayer.y +16).body.setAllowGravity(false).setImmovable(true);
                    });

                    // collisions
                    this.physics.add.collider(monstresLeft, limitesMonstresLeft);

    // LIMITES DU NIVEAU

        // LIMITES DU NIVEAU VIA DIMENSIONS
        this.physics.world.setBounds(0, 0, 1600, 1600);

        // PLAYER - Collision entre le joueur et les limites du niveau
        player.setCollideWorldBounds(true);

    // UI
        // LIFE
        lifeUI = this.add.sprite(0,0, 'lifeFull').setOrigin(0,0).setScrollFactor(0);

        // SCORE ESPRITS

            //IMAGE ESPRITS
            espritUi =this.add.sprite(1100, 40,'espritUI').setOrigin(0,0).setScrollFactor(0);
            
            //NOMBRE D'ESPRITS
            fondScore = this.add.sprite(1108,-6, 'fond_score').setOrigin(0,0).setScrollFactor(0);
            textScore =this.add.text(1150,50,`${espritScore}`,{fontSize:'32px',fill:'#FFFFFF'}).setOrigin(0,0).setScrollFactor(0);

    // ANIMATIONS
    
        // PLAYER - MARCHE GAUCHE
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('perso', {start:0,end:3}),
            frameRate: 10,
            repeat: -1
        });

        // PLAYER - MARCHE DROITE
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('perso', {start:5,end:8}),
            frameRate: 10,
            repeat: -1
        });

        // PLAYER - IDLE
        this.anims.create({
            key: 'turn',
            frames: [ { key: 'perso', frame: 4 } ],
            frameRate: 20
        });
    
    // COMMANDES

        // CLAVIER
            // DEPLACEMENTS FLECHES DIRECTIONNELLES
            cursors = this.input.keyboard.createCursorKeys();

            // DEPLACEMENT HORIZONTAUX - D et Q
            keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            keyQ = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);

            // SAUT (BARRE D'ESPACE)
            spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

            // WALL GRAP (SHIFT)
            keyWallGrap = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
        
        // MANETTE
        this.input.gamepad.once('connected', function (pad) {
            controller = pad;
        });

    // CAMERA

        // LIMITES CAMERA (champs de la caméra de taille identique à celle du niveau)
        this.cameras.main.setBounds(0, 0, 1600, 1600);
        
        // TAILLE
        this.cameras.main.setSize(1200, 750);

        // ANCRAGE CAMERA - JOUEUR
        this.cameras.main.startFollow(player);        

        // CAMERA - Zoom de la camera (RETIRE CAR FAIT BUGER L'AFFICHAGE DE L'UI)
        /*this.cameras.main.setZoom(3, 3);*/

    // ----------------------------------------------------- FIN FONCTION CREATE ----------------------------------------------
}

//FONCTION UPDATE - s'exécute à chaque frame du jeu
function update(){
    movementPlayer();
}

// --------------------------------- FONCTIONS ---------------------------------

// CARACTERISTIQUES DES PLATEFORMES

    //PLATEFORMES NORMALES (grotte et donjon)
    function normalPlatsProperties() {
        speedMoveX = 150;
        speedMoveY = 210;
        playerInertie = 0;
        wallIce = false;

        console.log("check wallIce + ", wallIce);
    }

    // PLATEFORMES NEIGE (ralentissement)
    function neigePlatsProperties() {
        speedMoveX = 100;
        speedMoveY = 210;
        playerInertie = 0;
        wallIce = false;

        console.log("check wallIce + ", wallIce);
    }

    // PLATEFORMES GLACE (inertie et wallgrab glissant)
    function glacePlatsProperties() {
        speedMoveX = 150;
        speedMoveY = 210;
        playerInertie = 3000;
        wallIce = true;

        console.log("check wallIce + ", wallIce);
    }

// CAPACITES DU JOUEUR AU SOL
function onFloorProperties(){
    
    if(player.body.onFloor()){ // si le joueur est au sol
        wallJumpLocked = true; //on ne peut pas walljump à partir du sol
        unlockCommandes(); // on débloque les commandes
        jumpLeft = jumpMax;
        
        if(wallIce == false){ // si pas de glace
        // Coupe l'inertie du saut
        player.setAccelerationX(playerInertie);
        }
    }
    
    else{
        wallJumpLocked = false; // si le joueur est pas au sol : wall jump débloqué
    }
}

// Déverouillage des commandes
function unlockCommandes(){
    commandesLocked = false;
}

// DEPLACEMENT PLAYER
function movementPlayer(){

    // Verification continue que le joueur est au sol ou à l'air. Débloquage de capacité en conséquent
    onFloorProperties();

    // DEPLACEMENT - GAUCHE
    if ((cursors.left.isDown || keyQ.isDown || controller.left) && commandesLocked == false){ //si la touche gauche est appuyée
        player.setVelocityX(-speedMoveX); //alors vitesse négative en X
        
        if(player.body.onFloor()){ // si joueur au sol
            player.anims.play('left', true); //animation marche gauche
            player.setAccelerationX(-playerInertie);
        }
    }

    // DEPLACEMENT - DROITE
    else if ((cursors.right.isDown || keyD.isDown || controller.right) && commandesLocked == false){ //sinon si la touche droite est appuyée
        player.setVelocityX(speedMoveX); //alors vitesse positive en X

        if(player.body.onFloor()){ // si joueur au sol
            player.anims.play('right', true); //animation marche droite
            player.setAccelerationX(playerInertie);
        }
    }

    // IDLE
    else { 
        player.setVelocityX(0); //vitesse nulle
        player.anims.play('turn'); //animation idle
    }

    // DEPLACEMENT - SAUT
    if ((cursors.up.isDown || spaceBar.isDown || controller.up || controller.A) && commandesLocked == false && (jumpLeft >= 1) && (coolDownJump == false)){

        // SAUT A TERRE
        /*if(player.body.onFloor()){*/
            
            jumpLeft -= 1;
            coolDownJump = true;

            setTimeout(function() {
                coolDownJump = false;
                console.log("REJUMP !");            
            }, 500);

            //si touche haut appuyée ET que le perso touche le sol
            player.setAccelerationY(10);
            player.setMaxVelocity(speedMoveY);
            player.setVelocityY(-speedMoveY); //alors vitesse verticale négative
            //(on saute)
    }

    // WALL JUMP

        // WALL JUMP GAUCHE
        if(player.body.blocked.left && (keyWallGrap.isDown || controller.R2 || controller.L2) && wallJumpLocked == false){

            jumpLeft = jumpMax;

            if(wallIce == true){ // si glace : on glisse le long du mur
                player.setVelocityY(20);
                player.setVelocityX(0);
            }
            else if(wallIce == false){ // si normal : on reste collé contre le mur
                player.setVelocityY(-5);
                player.setVelocityX(-2);
            }
            
            if (cursors.up.isDown || spaceBar.isDown || controller.up || controller.A){ // on se repousse du mur
                player.setAccelerationX(4000);
                player.setMaxVelocity(1000);
                player.setVelocityY(-speedMoveY);

                // commandes bloquées
                commandesLocked = true;
                console.log(commandesLocked)
                
                // commandes débloquées
                setTimeout(unlockCommandes, 2000);
            }
        }

        // WALL JUMP DROIT
        if(player.body.blocked.right && (keyWallGrap.isDown || controller.R2 || controller.L2) && wallJumpLocked == false){

            jumpLeft = jumpMax;

            if(wallIce == true){ // si glace : on glisse le long du mur
                player.setVelocityY(20);
                player.setVelocityX(0);
            }
            else if(wallIce == false){ // si normal : on reste collé contre le mur
                player.setVelocityY(-5);
                player.setVelocityX(2);
            }
            
            if (cursors.up.isDown || spaceBar.isDown || controller.up || controller.A){ // on se repousse du mur
                player.setAccelerationX(-4000);
                player.setMaxVelocity(1000);
                player.setVelocityY(-speedMoveY);

                // commandes bloquées
                commandesLocked = true;
                console.log(commandesLocked);

                // commandes débloquées
                setTimeout(unlockCommandes, 1000);
            }
        }
}

// COLLECTE ESPRIT
function collectEsprits(player, esprit){
    esprit.destroy(esprit.x, esprit.y);
    espritScore ++; // increment le score
    textScore.setText(`${espritScore}`); // montre le score actuel
    console.log(espritScore);
}

function unlockDoubleJump(player, powerUp){
    jumpMax += 1;
    powerUp.destroy(powerUp.x, powerUp.y);
}

// Gestion des frames d'invulnérabilité
function getContactMob() {
    if ( contactMob == false ) {
        return true
    }
    else {
        return false
    }
}

function toucheMobGauche(player, monstresLeft) {
    if(player.body.touching.right || player.body.touching.left || player.body.touching.up){
        if(invincibleOn == false){
            console.log("contact ennemi");

            health -= 1;
            gestionLife();

            console.log(health);
            invincible();
            setTimeout(finInvicible, 700); 
        }
    }
    else if (player.body.touching.down){
        monstresLeft.disableBody(true, true);
        player.setVelocityY(-210);
    }
}

// CONTACT AVEC UN MOB
function toucheMobDroite(player, monstresRight) {
    if(player.body.touching.right || player.body.touching.left || player.body.touching.up){
        if(invincibleOn == false){
            console.log("contact ennemi");

            health -= 1;
            gestionLife();

            console.log(health);
            invincible();
            setTimeout(finInvicible, 700); 
        }
    }
    else if (player.body.touching.down){
        monstresRight.disableBody(true, true);
        player.setVelocityY(-210);
    }
}

// Change l'interface et déclenche la mort si 0 PV
function gestionLife(){
    if (health == 4){
        lifeUI.setTexture('lifeFull');
    }
    if (health == 3){
        lifeUI.setTexture('life1');
    }
    if (health == 2){
        lifeUI.setTexture('life2');
    }
    if (health == 1){
        lifeUI.setTexture('life3');
    }
    if (health == 0){
        lifeUI.setTexture('lifeDead');
        killPlayer();
    }
}

// INVINCIBILITE SI TOUCHE MONSTRE

    // REND INVINCIBLE
    function invincible() {
        invincibleOn = true;
        console.log("invincible");

        // animation invincible
        playerInvisible();
    }

    // FIN INVINCIBLE
    function finInvicible() {
        invincibleOn = false;
        console.log("Peut se faire touché");
    }

    // ANIMATION - FRAME D'INVINCIBILITE

        // ANIMATION - FRAME D'INVINCIBILITE (PART 1 - INVISIBLE)
        function playerInvisible() {
            player.visible = false;
            setTimeout(playerVisible, 100);
        }

        // ANIMATION - FRAME D'INVINCIBILITE (PART 2 - VISIBLE)
        function playerVisible() {
            if (frameInvincible < 3) {
                console.log("visible");
                player.visible = true;
                setTimeout(playerInvisible, 100);   
                frameInvincible += 1;
            }
            else {
                player.visible = true;
                frameInvincible = 0;
            }
        }

// MORT DU JOUEUR
function killPlayer(){
    gameOver = true;
    player.setTint(0xff0000);
    player.anims.play('turn');
    this.physics.pause();
    lifeUI.setTexture('lifeDead');
    console.log("Check death 1");
}

// RESTART LE JEU
/*function respawn(){
    if (gameOver == true){
        
        player.setTint(0xff0000);
        player.anims.play('turn');

        gameOver = false;
        commandesLocked = true;

        console.log("Check death 2");

        //replace le joueur à la zone de départ
        
        /*setTimeout(player.body.reset(1352, 680), 8000);

        setTimeout(function() {
            player.body.reset(1352, 680);    
            player.setTint(000000);
            
            health = 4;
            frameInvincible = 0;

            commandesLocked = false;
            wallJumpLocked = false;

            espritScore = 0;
        }, 1000);

    }
}*/   
        </script>
    </body>
</html>