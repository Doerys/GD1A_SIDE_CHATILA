<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" /><title>Souls Guardian</title>

        <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

        <style type="text/css"> body { margin: 0; }</style>>
    </head>
    <body>
        <script type="text/javascript">
            
            var config = {
                type: Phaser.AUTO,

                // Dimensions de l'espace de la fenêtre alloué au jeu
                width: 1200, height: 750,
                
                // Physique du jeu (gravité)
                physics: {
                    default: 'arcade',
                    arcade: {
                    gravity: { y: 600 },
                    fps: 50,
                    debug: true
                    }},

                input:{gamepad:true},
                scene: {preload: preload, create: create, update: update }
                };

                new Phaser.Game(config);

// VARIABLES
let platforms;
let player;
let espritsLayer;

let cursors;

let health = 4;
let frameInvincible = 0;
let invincibleOn = false;

let gameOver = false;

let commandesLocked = false;
let wallJumpLocked = false;

let esprits;
let textScore;
let espritScore = 0;

let porteVertDisable = true;
let porteRoseDisable = false;

let clefScore = 0;

let wallNeige = false;
let wallIce = false;

let doubleJumpAbility = true;
let didPressJump = false;
let canDoubleJump = false;

let picsRetractOn = false;

let chutePicGlace = false;

var controller = false; //manette

// FONCTION PRELOAD - précharger en mémoire les éléments de notre jeu (assets)
function preload(){

    // Player
    this.load.spritesheet('perso','assets/perso.png',
        { frameWidth: 32, frameHeight: 48 });

    // BACKGROUND
    this.load.image('background', 'assets/background.png');
    this.load.image('secondPlan', 'assets/secondPlan.png'); 

    // UI
        // UI - LIFE
            this.load.image('lifeFull',"assets/Life_Full.png");
            this.load.image('life1',"assets/Life_Hurt_1.png");
            this.load.image('life2',"assets/Life_Hurt_2.png");
            this.load.image('life3',"assets/Life_Hurt_3.png");
            this.load.image('lifeDead',"assets/Life_Dead.png");

        // UI - ESPRITS
            this.load.image('fond_score', 'assets/fond_chiffre.png');
            this.load.image('espritUI', "assets/esprit.png");

    // PLATEFORMES
        this.load.tilemapTiledJSON("carte", "assets/map.json");
        this.load.image("Phaser_tuilesdejeu", "assets/tuilesJeu.png");

    // OBSTACLES
        this.load.image('cristauxImage', 'assets/cristaux.png');

        this.load.image('picsBasImage', 'assets/picsBas.png');
        this.load.image('picsHautImage', 'assets/picsHaut.png');
        this.load.image('picsDroiteImage', 'assets/picsDroite.png');
        this.load.image('picsGaucheImage', 'assets/picsGauche.png');

        this.load.image('retractPicsBasOn', 'assets/extractPicsBas.png');
        this.load.image('retractPicsHautOn', 'assets/extractPicsHaut.png');
        this.load.image('retractPicsDroiteOn', 'assets/extractPicsDroite.png');
        this.load.image('retractPicsGaucheOn', 'assets/extractPicsGauche.png');

        this.load.image('retractPicsBasOff', 'assets/retractPicsBas.png');
        this.load.image('retractPicsHautOff', 'assets/retractPicsHaut.png');
        this.load.image('retractPicsDroiteOff', 'assets/retractPicsDroite.png');
        this.load.image('retractPicsGaucheOff', 'assets/retractPicsGauche.png');

        this.load.image('laveImage', 'assets/lava.png');
        
        this.load.image('picsGlaceBasImage', 'assets/picsGlaceBas.png');        
        this.load.image('picsGlaceHautImage', 'assets/picsGlaceHaut.png');
        this.load.image('picsGlaceDroiteImage', 'assets/picsGlaceDroite.png');
        this.load.image('picsGlaceGaucheImage', 'assets/picsGlaceGauche.png');

        this.load.image('glaceFragileImage', 'assets/glaceFragile.png');



    // MOBS
        // Préchargement apparence monstre
            this.load.image('monsterRightApparence', 'assets/monstre_right.png');
            this.load.image('monsterLeftApparence', 'assets/monstre_left.png');

    // ELEMENTS INTERACTIFS

        // BOUTON ET PORTE ROSE
        this.load.image('boutonRoseImage', 'assets/boutonRose.png');        
        this.load.image('porteRoseImage', 'assets/porteRose.png');

        // BOUTON ET PORTE VERTE
        this.load.image('boutonVertImage', 'assets/boutonVert.png');        
        this.load.image('porteVertImage', 'assets/porteVerte.png');
    
    // PICK UPS OBJECTS
    this.load.image('espritCollectible', 'assets/esprit_in_game.png');
    this.load.image("powerUpImage", 'assets/powerUp.png');

    this.load.image('clefsImage', 'assets/clef.png');
    this.load.image('porteFinale', 'assets/porteFinale.png');

    // ----------------------------------------------------- FIN FONCTION PRELOAD ----------------------------------------------

}

// FONCTION CREATE - Gère le stade initial du jeu
function create(){

    // ARRIERE PLAN

        // ARRIERE PLAN - BACKGROUND
        this.backgroundParallax = this.add.tileSprite(0, 0, 1600, 1600, "background");
        this.backgroundParallax.setOrigin(0, 0);
        this.backgroundParallax.setScrollFactor(0.7, 1);

        // ARRIERE PLAN - SECOND PLAN
        this.sndPlanParallax = this.add.tileSprite(0, 0, 1600, 1600, "secondPlan");
        this.sndPlanParallax.setOrigin(0, 0);
        this.sndPlanParallax.setScrollFactor(0.5, 1);

    // PLAYER
        //player = this.physics.add.sprite(1350, 650, 'perso');
        //player = this.physics.add.sprite(450, 900, 'perso');
        player = this.physics.add.sprite(450, 500, 'perso');
        //player = this.physics.add.sprite(1350, 650, 'perso');

    // MAP DE TILED
        // TILEMAP    
            const carteDuNiveau = this.add.tilemap("carte");

        // TILESET
            const tileset = carteDuNiveau.addTilesetImage("tuiles_de_jeu","Phaser_tuilesdejeu",);

            //CRISTAUX
                //récupération
                cristaux = this.physics.add.staticGroup();
                cristauxLayer = carteDuNiveau.getObjectLayer('cristauxLayer')['objects'];
            
                // creation
                cristauxLayer.forEach(object => {
                    let obj = cristaux.create(object.x + 16, object.y -16, 'cristauxImage');
                    obj.setScale(object.width/32, object.height/32);
                    obj.body.width = object.width;
                    obj.body.height = object.height;
                });
            
                // collisions
                this.physics.add.overlap(player, cristaux, killPlayer, null, this);

            // PLATEFORMES NORMALES []
                const plateformes = carteDuNiveau.createLayer("plateformes",tileset);

                // collisions
                plateformes.setCollisionByProperty({estSolide: true });
                this.physics.add.collider(player, plateformes, normalPlatsProperties, null, this);


            // PLATEFORMES NEIGE
                const plateformesNeige = carteDuNiveau.createLayer("plateformesNeige",tileset);

                // collisions
                plateformesNeige.setCollisionByProperty({estNeige : true });
                this.physics.add.collider(player, plateformesNeige, neigePlatsProperties, null, this);

            // PLATEFORMES GLACE __
                const plateformesGlace = carteDuNiveau.createLayer("plateformesGlace",tileset);

                // collisions
                plateformesGlace.setCollisionByProperty({estGlace : true });
                this.physics.add.collider(player, plateformesGlace, glacePlatsProperties, null, this);

        // OBJECTS

            // ELEMENTS INTERACTIFS

                // BOUTON ROSE

                    //récupération
                    boutonRose = this.physics.add.staticGroup();
                    boutonRoseLayer = carteDuNiveau.getObjectLayer('boutonRoseLayer')['objects'];
                    
                    // creation
                    boutonRoseLayer.forEach(object => {
                    let obj = boutonRose.create(object.x + 16, object.y -11, 'boutonRoseImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.overlap(player, boutonRose, pressBoutonRose, null, this);

                // PORTE ROSE

                    //récupération
                    porteRose = this.physics.add.staticGroup();
                    porteRoseLayer = carteDuNiveau.getObjectLayer('porteRoseLayer')['objects'];
                    
                    // creation
                    porteRoseLayer.forEach(object => {
                    let obj = porteRose.create(object.x + 16, object.y +32, 'porteRoseImage');
                        obj.setScale(object.width/32, object.height/64);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.collider(player, porteRose, disablePorteRose, null, this);

                // BOUTON VERT

                    //récupération
                    boutonVert = this.physics.add.staticGroup();
                    boutonVertLayer = carteDuNiveau.getObjectLayer('boutonVertLayer')['objects'];
                    
                    // creation
                    boutonVertLayer.forEach(object => {
                    let obj = boutonVert.create(object.x + 16, object.y -16, 'boutonVertImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.overlap(player, boutonVert, pressBoutonVert, null, this);

                // PORTE VERTE

                    //récupération
                    porteVert = this.physics.add.staticGroup();
                    porteVertLayer = carteDuNiveau.getObjectLayer('porteVerteLayer')['objects'];
                    
                    // creation
                    porteVertLayer.forEach(object => {
                    let obj = porteVert.create(object.x + 16, object.y +32, 'porteVertImage');
                        obj.setScale(object.width/32, object.height/64);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.collider(player, porteVert, disablePorteVert, null, this);
        
            //CLEFS
                //récupération
                clef = this.physics.add.staticGroup();
                clefsLayer = carteDuNiveau.getObjectLayer('clefsLayer')['objects'];
                
                // creation
                clefsLayer.forEach(object => {
                let obj = clef.create(object.x + 16, object.y -16, 'clefsImage');
                    obj.setScale(object.width/32, object.height/32);
                    obj.body.width = object.width;
                    obj.body.height = object.height;
                });

                // collisions
                this.physics.add.overlap(player, clef, collectClefs, null, this);

            //PORTE FINALE
                //récupération
                porteFinale = this.physics.add.staticGroup();
                porteFinaleLayer = carteDuNiveau.getObjectLayer('porteFinaleLayer')['objects'];
                
                // creation
                porteFinaleLayer.forEach(object => {
                let obj = porteFinale.create(object.x + 16, object.y+48, 'porteFinale');
                    obj.setScale(object.width/32, object.height/96);
                    obj.body.width = object.width;
                    obj.body.height = object.height;
                });

                // collisions
                this.physics.add.collider(player, porteFinale, disablePorteFinale, null, this);

            // PICK-UP-OBJECTS 
                
                //ESPRITS
                    //récupération
                    esprits = this.physics.add.staticGroup();
                    espritsLayer = carteDuNiveau.getObjectLayer('espritsLayer')['objects'];
                    
                    // creation
                    espritsLayer.forEach(object => {
                    let obj = esprits.create(object.x + 16, object.y -16, 'espritCollectible');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.overlap(player, esprits, collectEsprits, null, this);
                    
                // POWER UP - DOUBLE JUMP

                powerUp = this.physics.add.staticGroup();
                powerUpLayer = carteDuNiveau.getObjectLayer('powerUpLayer')['objects'];
                
                // creation
                powerUpLayer.forEach(object => {
                let obj = powerUp.create(object.x + 16, object.y -16, 'powerUpImage');
                    obj.setScale(object.width/32, object.height/32);
                    obj.body.width = object.width;
                    obj.body.height = object.height;
                });

                // collisions
                this.physics.add.overlap(player, powerUp, unlockDoubleJump, null, this);

            // OBSTACLES

                // PLATEFORMES GLACE FRAGILES

                    //récupération
                    platsGlaceFragile = this.physics.add.staticGroup();
                    platsGlaceFragileLayer = carteDuNiveau.getObjectLayer('platsGlaceFragileLayer')['objects'];
                    
                        // creation
                        platsGlaceFragileLayer.forEach(object => {
                            let obj = platsGlaceFragile.create(object.x + 16, object.y -16, 'glaceFragileImage');
                            obj.setScale(object.width/32, object.height/32);
                            obj.body.width = object.width;
                            obj.body.height = object.height;
                        });
                    
                        // collisions
                        this.physics.add.collider(player, platsGlaceFragile, destructionGlace, null, this);

                // PICS BAS

                    //récupération
                    picsBas = this.physics.add.staticGroup();
                    picsBasLayer = carteDuNiveau.getObjectLayer('picsBasLayer')['objects'];
                    
                        // creation
                        picsBasLayer.forEach(object => {
                            let obj = picsBas.create(object.x + 16, object.y -16, 'picsBasImage');
                            obj.setScale(object.width/32, object.height/32);
                            obj.body.width = object.width;
                            obj.body.height = object.height;
                        });
                    
                        // collisions
                        this.physics.add.overlap(player, picsBas, killPlayer, null, this);
        
                // PICS HAUT

                    //récupération
                    picsHaut = this.physics.add.staticGroup();
                    picsHautLayer = carteDuNiveau.getObjectLayer('picsHautLayer')['objects'];
                    
                    // creation
                    picsHautLayer.forEach(object => {
                        let obj = picsHaut.create(object.x + 16, object.y -16, 'picsHautImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsHaut, killPlayer, null, this);

                // PICS DROITE

                    //récupération
                    picsDroite = this.physics.add.staticGroup();
                    picsDroiteLayer = carteDuNiveau.getObjectLayer('picsDroiteLayer')['objects'];
                    
                    // creation
                    picsDroiteLayer.forEach(object => {
                        let obj = picsDroite.create(object.x + 16, object.y -16, 'picsDroiteImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsDroite, killPlayer, null, this);

                // PICS GAUCHE

                    //récupération
                    picsGauche = this.physics.add.staticGroup();
                    picsGaucheLayer = carteDuNiveau.getObjectLayer('picsGaucheLayer')['objects'];
                    
                    // creation
                    picsGaucheLayer.forEach(object => {
                        let obj = picsGauche.create(object.x + 16, object.y -16, 'picsGaucheImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGauche, killPlayer, null, this);

                // LAVE

                    //récupération
                    lave = this.physics.add.staticGroup();
                    laveLayer = carteDuNiveau.getObjectLayer('laveLayer')['objects'];
                    
                    // creation
                    laveLayer.forEach(object => {
                        let obj = lave.create(object.x + 16, object.y -10, 'laveImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, lave, killPlayer, null, this);

                // PICS GLACE BAS

                    //récupération
                    picsGlaceBas = this.physics.add.staticGroup();
                    picsGlaceBasLayer = carteDuNiveau.getObjectLayer('picsGlaceBasLayer')['objects'];
                    
                    // creation
                    picsGlaceBasLayer.forEach(object => {
                        let obj = picsGlaceBas.create(object.x + 16, object.y -16, 'picsGlaceBasImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceBas, killPlayer, null, this);

                // PICS GLACE DROITE

                    //récupération
                    picsGlaceDroite = this.physics.add.staticGroup();
                    picsGlaceDroiteLayer = carteDuNiveau.getObjectLayer('picsGlaceDroiteLayer')['objects'];
                    
                    // creation
                    picsGlaceDroiteLayer.forEach(object => {
                        let obj = picsGlaceDroite.create(object.x + 16, object.y -16, 'picsGlaceDroiteImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceDroite, killPlayer, null, this);

                // PICS GLACE GAUCHE

                    //récupération
                    picsGlaceGauche = this.physics.add.staticGroup();
                    picsGlaceGaucheLayer = carteDuNiveau.getObjectLayer('picsGlaceGaucheLayer')['objects'];
                    
                    // creation
                    picsGlaceGaucheLayer.forEach(object => {
                        let obj = picsGlaceGauche.create(object.x + 16, object.y -16, 'picsGlaceGaucheImage');
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });
                    
                    // collisions
                    this.physics.add.overlap(player, picsGlaceGauche, killPlayer, null, this);

                // TRIGGER PICS GLACE HAUT

                    //récupération
                    triggerPicsGlace = this.physics.add.staticGroup();
                    triggerPicsGlaceLayer = carteDuNiveau.getObjectLayer('triggerPicsGlaceLayer')['objects'];

                    // creation
                    triggerPicsGlaceLayer.forEach(object => {
                        let obj = triggerPicsGlace.create(object.x + 16, object.y+16).setVisible(false);
                        obj.setScale(object.width/32, object.height/32);
                        obj.body.width = object.width;
                        obj.body.height = object.height;
                    });

                    // collisions
                    this.physics.add.overlap(player, triggerPicsGlace, detectTrigger, null, this);

                // PICS GLACE HAUT (QUI TOMBE)

                    //récupération
                    picsGlaceHaut = this.physics.add.group();
                    picsGlaceHautLayer = carteDuNiveau.getObjectLayer('picsGlaceHautLayer');
              
                    // creation
                    picsGlaceHautLayer.objects.forEach( picsGlaceHautLayer => {
                        const PicsGlaceHautLayer = picsGlaceHaut.create( picsGlaceHautLayer.x+16, picsGlaceHautLayer.y - 16, "picsGlaceHautImage").body.setAllowGravity(false);
                    });

                    // collisions
                    this.physics.add.overlap(triggerPicsGlace, picsGlaceHaut, physicAllowPicGlace, null, this);
                    this.physics.add.overlap(player, picsGlaceHaut, killPlayer, null, this);
                    this.physics.add.collider(plateformesNeige, picsGlaceHaut, destroyPicGlace, null, this);
                    this.physics.add.collider(plateformesGlace, picsGlaceHaut, destroyPicGlace, null, this);
                    this.physics.add.collider(platsGlaceFragile, picsGlaceHaut, destroyPicGlace, null, this);

                    // PICS RETRACTABLES BAS

                        // OFF
                        //récupération
                        retractPicsBasOff = this.physics.add.staticGroup();
                        retractPicsBasOffLayer = carteDuNiveau.getObjectLayer('retractPicsBasOffLayer')['objects'];
                        // creation
                        retractPicsBasOffLayer.forEach(object => {
                            let obj = retractPicsBasOff.create(object.x +16, object.y-7, 'retractPicsBasOff');
                            obj.setScale(object.width/32, object.height/32);
                            obj.body.width = object.width;
                            obj.body.height = object.height;
                        });

                        // ON
                            //récupération
                            retractPicsBas = this.physics.add.staticGroup();
                            retractPicsBasLayer = carteDuNiveau.getObjectLayer('retractPicsBasLayer')['objects'];
                            // creation
                            retractPicsBasLayer.forEach(object => {
                                let obj = retractPicsBas.create(object.x + 16, object.y -16, 'retractPicsBasOn');
                                obj.setScale(object.width/32, object.height/32);
                                obj.body.width = object.width;
                                obj.body.height = object.height;
                            });
                            // collisions
                            this.physics.add.overlap(player, retractPicsBas, picsRetractablesKill, null, this);

                    // PICS RETRACTABLES DROITE

                        // OFF
                            //récupération
                            retractPicsDroiteOff = this.physics.add.staticGroup();
                            retractPicsDroiteOffLayer = carteDuNiveau.getObjectLayer('retractPicsDroiteOffLayer')['objects'];
                            // creation
                            retractPicsDroiteOffLayer.forEach(object => {
                                let obj = retractPicsDroiteOff.create(object.x +24, object.y-16, 'retractPicsDroiteOff');
                                obj.setScale(object.width/32, object.height/32);
                                obj.body.width = object.width;
                                obj.body.height = object.height;
                            });

                        // ON
                            //récupération
                            retractPicsDroite = this.physics.add.staticGroup();
                            retractPicsDroiteLayer = carteDuNiveau.getObjectLayer('retractPicsDroiteLayer')['objects'];
                            // creation
                            retractPicsDroiteLayer.forEach(object => {
                                let obj = retractPicsDroite.create(object.x + 16, object.y -16, 'retractPicsDroiteOn');
                                obj.setScale(object.width/32, object.height/32);
                                obj.body.width = object.width;
                                obj.body.height = object.height;
                            });
                            // collisions
                            this.physics.add.overlap(player, retractPicsDroite, picsRetractablesKill, null, this);

                    // PICS RETRACTABLES GAUCHE

                        // OFF
                            //récupération
                            retractPicsGaucheOff = this.physics.add.staticGroup();
                            retractPicsGaucheOffLayer = carteDuNiveau.getObjectLayer('retractPicsGaucheOffLayer')['objects'];
                            // creation
                            retractPicsGaucheOffLayer.forEach(object => {
                                let obj = retractPicsGaucheOff.create(object.x+7, object.y-16, 'retractPicsGaucheOff');
                                obj.setScale(object.width/32, object.height/32);
                                obj.body.width = object.width;
                                obj.body.height = object.height;
                            });

                        // ON
                            //récupération
                            retractPicsGauche = this.physics.add.staticGroup();
                            retractPicsGaucheLayer = carteDuNiveau.getObjectLayer('retractPicsGaucheLayer')['objects'];
                            // creation
                            retractPicsGaucheLayer.forEach(object => {
                                let obj = retractPicsDroite.create(object.x + 16, object.y -16, 'retractPicsGaucheOn');
                                obj.setScale(object.width/32, object.height/32);
                                obj.body.width = object.width;
                                obj.body.height = object.height;
                            });
                            // collisions
                            this.physics.add.overlap(player, retractPicsGauche, picsRetractablesKill, null, this);

            //MOBS 
                // MONSTRES VERS DROITE
                    // récupération
                    monstresRight = this.physics.add.group();
                    monstresRightLayer = carteDuNiveau.getObjectLayer('monstresRightLayer');
                    
                    // creation
                    monstresRightLayer.objects.forEach( monstresRightLayer => {
                        const MmonstresRightLayer = monstresRight.create( monstresRightLayer.x + 16, monstresRightLayer.y + 16, "monsterRightApparence").body.setAllowGravity(false).setBounce(1);
                    });
                    monstresRight.setVelocity(0, 100);

                    // collisions
                    this.physics.add.overlap(player, monstresRight, toucheMobDroite, null, this);

                //MONSTRES VERS GAUCHE
                    // récupération
                    monstresLeft = this.physics.add.group();
                    monstresLeftLayer = carteDuNiveau.getObjectLayer('monstresLeftLayer');
                    
                    // creation
                    monstresLeftLayer.objects.forEach( monstresLeftLayer => {
                        const MMonstresLeftLayer = monstresLeft.create( monstresLeftLayer.x + 16, monstresLeftLayer.y + 16, "monsterLeftApparence").body.setAllowGravity(false).setBounce(1);
                    });
                    monstresLeft.setVelocity(0, 100);

                    // collisions
                    this.physics.add.overlap(player, monstresLeft, toucheMobGauche, null, this);

                //BORDURES MONSTRES RIGHT (délimitant les déplacements des Ennemis de droite)
                    // récupération
                    limitesMonstresRight = this.physics.add.group();
                    limitesMonstresRightLayer = carteDuNiveau.getObjectLayer('limitesMonstresRightLayer');
                    
                    // création
                    limitesMonstresRightLayer.objects.forEach( limitesMonstresRightLayer => {
                        const LimitesMonstresRightLayer = limitesMonstresRight.create( limitesMonstresRightLayer.x + 16, limitesMonstresRightLayer.y +16).setVisible(false).body.setAllowGravity(false).setImmovable(true);
                    });

                    // collisions
                    this.physics.add.collider(monstresRight, limitesMonstresRight);

                //BORDURES MONSTRES LEFT (délimitant les déplacements des Ennemis de gauche)
                    // récupération
                    limitesMonstresLeft = this.physics.add.group();
                    limitesMonstresLeftLayer = carteDuNiveau.getObjectLayer('limitesMonstresLeftLayer');
                    
                    // création
                    limitesMonstresLeftLayer.objects.forEach( limitesMonstresLeftLayer => {
                        const LimitesMonstresLeftLayer = limitesMonstresLeft.create( limitesMonstresLeftLayer.x + 16, limitesMonstresLeftLayer.y +16).setVisible(false).body.setAllowGravity(false).setImmovable(true);
                    });

                    // collisions
                    this.physics.add.collider(monstresLeft, limitesMonstresLeft);

    // LIMITES DU NIVEAU

        // LIMITES DU NIVEAU VIA DIMENSIONS
        this.physics.world.setBounds(0, 0, 1600, 1600);

        // PLAYER - Collision entre le joueur et les limites du niveau
        player.setCollideWorldBounds(true);

    // UI
        // LIFE
        lifeUI = this.add.sprite(0,0, 'lifeFull').setOrigin(0,0).setScrollFactor(0);

        // SCORE ESPRITS

            //IMAGE ESPRITS
            espritUi =this.add.sprite(1100, 40,'espritUI').setOrigin(0,0).setScrollFactor(0);
            
            //NOMBRE D'ESPRITS
            fondScore = this.add.sprite(1108,-6, 'fond_score').setOrigin(0,0).setScrollFactor(0);
            textScore =this.add.text(1150,50,`${espritScore}`,{fontSize:'32px',fill:'#FFFFFF'}).setOrigin(0,0).setScrollFactor(0);

    // ANIMATIONS
    
        // PLAYER - MARCHE GAUCHE
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('perso', {start:0,end:3}),
            frameRate: 10,
            repeat: -1
        });

        // PLAYER - MARCHE DROITE
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('perso', {start:5,end:8}),
            frameRate: 10,
            repeat: -1
        });

        // PLAYER - IDLE
        this.anims.create({
            key: 'turn',
            frames: [ { key: 'perso', frame: 4 } ],
            frameRate: 20
        });
    
    // COMMANDES

        // CLAVIER
            // DEPLACEMENTS FLECHES DIRECTIONNELLES
            cursors = this.input.keyboard.createCursorKeys();

            // DEPLACEMENT HORIZONTAUX - D et Q
            keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            keyQ = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);

            // INTERACTIONS

            keyE = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

            // SAUT (BARRE D'ESPACE)
            spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

            // WALL GRAP (SHIFT)
            keyWallGrap = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
        
        // MANETTE
        this.input.gamepad.once('connected', function (pad) {
            controller = pad;
        });

    // CAMERA

        // LIMITES CAMERA (champs de la caméra de taille identique à celle du niveau)
        this.cameras.main.setBounds(0, 0, 1600, 1600);
        
        // TAILLE
        this.cameras.main.setSize(1200, 750);

        // ANCRAGE CAMERA - JOUEUR
        this.cameras.main.startFollow(player);        

        // CAMERA - Zoom de la camera (RETIRE CAR FAIT BUGER L'AFFICHAGE DE L'UI)
        this.cameras.main.setZoom(3, 3);

    // ----------------------------------------------------- FIN FONCTION CREATE ----------------------------------------------
}

//FONCTION UPDATE - s'exécute à chaque frame du jeu
function update(){
    picsRetractablesAnim();
    movementPlayer();
    //respawn();
}

// --------------------------------- FONCTIONS ---------------------------------

// CARACTERISTIQUES DES PLATEFORMES

    //PLATEFORMES NORMALES (grotte et donjon)
    function normalPlatsProperties() {
        speedMoveX = 150;
        speedMoveY = 280;
        playerInertie = 0;
        wallNeige = false;
        wallIce = false;
    }

    // PLATEFORMES NEIGE (ralentissement)
    function neigePlatsProperties() {
        speedMoveX = 100;
        speedMoveY = 280;
        playerInertie = 0;
        wallNeige = true;
        wallIce = false;
    }

    // PLATEFORMES GLACE (inertie et wallgrab glissant)
    function glacePlatsProperties() {
        speedMoveX = 150;
        speedMoveY = 280;
        playerInertie = 3000;
        wallNeige = false;
        wallIce = true;
    }

// CAPACITES DU JOUEUR AU SOL
function onFloorProperties(){
    
    if(player.body.onFloor()){ // si le joueur est au sol
        wallJumpLocked = true; //on ne peut pas walljump à partir du sol
        unlockCommandes(); // on débloque les commandes

        if(wallIce == false){ // si pas de glace
        // Coupe l'inertie du saut
        player.setAccelerationX(playerInertie);
        }
    }
    
    else{
        wallJumpLocked = false; // si le joueur est pas au sol : wall jump débloqué
    }
}

// Déverouillage des commandes
function unlockCommandes(){
    commandesLocked = false;
}

// DEPLACEMENT PLAYER
function movementPlayer(){

    // Verification continue que le joueur est au sol ou à l'air. Débloquage de capacité en conséquent
    onFloorProperties();

    // DEPLACEMENT - GAUCHE
    if ((cursors.left.isDown || keyQ.isDown || controller.left) && commandesLocked == false){ //si la touche gauche est appuyée
        player.setVelocityX(-speedMoveX); //alors vitesse négative en X
        
        if(player.body.onFloor()){ // si joueur au sol
            player.anims.play('left', true); //animation marche gauche
            player.setAccelerationX(-playerInertie);
        }
    }

    // DEPLACEMENT - DROITE
    else if ((cursors.right.isDown || keyD.isDown || controller.right) && commandesLocked == false){ //sinon si la touche droite est appuyée
        player.setVelocityX(speedMoveX); //alors vitesse positive en X

        if(player.body.onFloor()){ // si joueur au sol
            player.anims.play('right', true); //animation marche droite
            player.setAccelerationX(playerInertie);
        }
    }

    // IDLE
    else { 
        player.setVelocityX(0); //vitesse nulle
        player.anims.play('turn'); //animation idle
    }

    // DEPLACEMENT - SAUT
    
    if ((cursors.up.isDown || spaceBar.isDown || controller.up || controller.A) && commandesLocked == false){
        didPressJump = true;

        if(didPressJump == true){
            if (player.body.onFloor()) {
                // player can only double jump if it is on the floor
                player.body.setVelocityY(-speedMoveY);
                didPressJump = false;
                console.log("saut = ", speedMoveY);

                setTimeout(function() {
                    if(doubleJumpAbility == true){
                        canDoubleJump = true;
                        console.log("JUMP" + canDoubleJump);  
                    }  
                }, 500);              

            } else if (canDoubleJump == true) {
                // player can only jump 2x (double jump)
                canDoubleJump = false;
                player.body.setVelocityY(-speedMoveY);
                console.log("DOUBLE JUMP !")
            }
        }
    }

    // WALL JUMP

        // WALL JUMP GAUCHE
        if(player.body.blocked.left && (keyWallGrap.isDown || controller.R2 || controller.L2) && wallJumpLocked == false){

            if(wallNeige == true){ // si neige : on glisse le long du mur
                player.setVelocityY(30);
                player.setVelocityX(0);
            }
            else if((wallNeige == false) && (wallIce == false)){ // si normal : on reste collé contre le mur
                player.setVelocityY(-12);
                player.setVelocityX(-2);
            }
            
            if ((cursors.up.isDown || spaceBar.isDown || controller.up || controller.A) && (wallIce == false)){ // on se repousse du mur
                // commandes bloquées
                commandesLocked = true;

                player.setAccelerationX(0);
                
                player.setAccelerationX(4000);
                player.setMaxVelocity(1000);
                player.setVelocityY(-speedMoveY);

                console.log(player.acceleration);

                /*setTimeout(function(){
                    canDoubleJump = true;
                }, 100);*/
                
                // commandes débloquées
                setTimeout(function() {
                unlockCommandes();
                player.setAccelerationX(0);                
                }, 2000);
            }
        }

        // WALL JUMP DROIT
        if(player.body.blocked.right && (keyWallGrap.isDown || controller.R2 || controller.L2) && wallJumpLocked == false){

            if(wallNeige == true){ // si glace : on glisse le long du mur
                player.setVelocityY(20);
                player.setVelocityX(0);
            }
            else if((wallNeige == false) && (wallIce == false)){ // si normal : on reste collé contre le mur
                player.setVelocityY(-12);
                player.setVelocityX(2);
            }
            
            if ((cursors.up.isDown || spaceBar.isDown || controller.up || controller.A) && (wallIce == false)){ // on se repousse du mur
                // commandes bloquées
                commandesLocked = true;
                
                player.setAccelerationX(0);
                
                player.setAccelerationX(-4000);
                player.setMaxVelocity(1000);
                player.setVelocityY(-speedMoveY);

                /*setTimeout(function(){
                    canDoubleJump = true;
                }, 100);*/

                // commandes débloquées
                setTimeout(function() {
                unlockCommandes();
                player.setAccelerationX(0);                
                }, 2000);
            }
        }
}

// COLLECTE ESPRIT
function collectEsprits(player, esprit){
    esprit.destroy(esprit.x, esprit.y);
    espritScore ++; // increment le score
    textScore.setText(`${espritScore}`); // montre le score actuel
    console.log(espritScore);
}

function collectClefs(player, clef){
    clef.destroy(clef.x, clef.y);
    clefScore ++;
    console.log(clefScore);
}

function disablePorteFinale(player, porteFinale){
    if (clefScore == 2){
        porteFinale.destroy();        
    }
}

function pressBoutonRose(player, boutonRose){
    if (cursors.down.isDown || keyE.isDown || controller.B){
        porteRoseDisable = true;
        porteRose.setActive(false).setVisible(false);
    }

}

function pressBoutonVert(player, boutonVert){
    if (cursors.down.isDown || keyE.isDown || controller.B){
        porteVertDisable = true;
        porteVert.setActive(false).setVisible(false);
    }
}

function disablePorteVert(player, porteVert){
    if(porteVertDisable == true){
        porteVert.destroy();
    }
}

function disablePorteRose(player, porteRose){
    if (porteRoseDisable == true){
        porteRose.destroy();
    }
}

function unlockDoubleJump(player, powerUp){
    doubleJumpAbility = true;
    powerUp.destroy(powerUp.x, powerUp.y);
}

function destructionGlace(player, platsGlaceFragile){
    speedMoveX = 150;
    speedMoveY = 280;
    playerInertie = 3000;
    wallNeige = true;
    setTimeout(function() {
        platsGlaceFragile.destroy();
    }, 1000); 
}

function physicAllowPicGlace(triggerPicsGlace, picsGlaceHaut){
    if (chutePicGlace == true){
        chutePicGlace = false;
        triggerPicsGlace.destroy();
        
        setTimeout(function(){
            picsGlaceHaut.body.setAllowGravity(true);
        }, 500);        
    }

}

function detectTrigger(player, triggerPicsGlace){
    chutePicGlace = true;
}

function destroyPicGlace(picsGlaceHaut){
    picsGlaceHaut.destroy();
}

    // ANIMATION DES PICS RETRACTABLES

        function picsRetractablesAnim() {
            if (picsRetractOn == false) {
                retractPicsBasOff.setActive(true).setVisible(true);
                retractPicsBas.setActive(false).setVisible(false);

                retractPicsDroiteOff.setActive(true).setVisible(true);
                retractPicsDroite.setActive(false).setVisible(false);

                setTimeout(function() {
                    picsRetractOn = true;
                }, 2000);   
            }

            if (picsRetractOn == true) {
                retractPicsBasOff.setActive(false).setVisible(false);
                retractPicsBas.setActive(true).setVisible(true);

                retractPicsDroiteOff.setActive(false).setVisible(false);
                retractPicsDroite.setActive(true).setVisible(true);

                setTimeout(function() {
                    picsRetractOn = false;
                }, 2000);   
            }
        }

        function picsRetractablesKill(player, retractPicsBas){
            if (picsRetractOn == true){
                console.log("KILL PLAYER AVEC PICS !");
                killPlayer();
            }
        }

// Gestion des frames d'invulnérabilité
function getContactMob() {
    if ( contactMob == false ) {
        return true
    }
    else {
        return false
    }
}

function toucheMobGauche(player, monstresLeft) {
    if(player.body.touching.right || player.body.touching.left || player.body.touching.up){
        if(invincibleOn == false){
            console.log("contact ennemi");

            health -= 1;
            gestionLife();

            console.log(health);
            invincible();
            setTimeout(finInvicible, 700); 
        }
    }
    else if (player.body.touching.down){
        monstresLeft.disableBody(true, true);
        player.setVelocityY(-210);
    }
}

// CONTACT AVEC UN MOB
function toucheMobDroite(player, monstresRight) {
    if(player.body.touching.right || player.body.touching.left || player.body.touching.up){
        if(invincibleOn == false){
            console.log("contact ennemi");

            health -= 1;
            gestionLife();

            console.log(health);
            invincible();
            setTimeout(finInvicible, 700); 
        }
    }
    else if (player.body.touching.down){
        monstresRight.disableBody(true, true);
        player.setVelocityY(-210);
    }
}

// Change l'interface et déclenche la mort si 0 PV
function gestionLife(){
    if (health == 4){
        lifeUI.setTexture('lifeFull');
    }
    if (health == 3){
        lifeUI.setTexture('life1');
    }
    if (health == 2){
        lifeUI.setTexture('life2');
    }
    if (health == 1){
        lifeUI.setTexture('life3');
    }
    if (health == 0){
        lifeUI.setTexture('lifeDead');
        killPlayer();
    }
}

// INVINCIBILITE SI TOUCHE MONSTRE

    // REND INVINCIBLE
    function invincible() {
        invincibleOn = true;
        console.log("invincible");

        // animation invincible
        playerInvisible();
    }

    // FIN INVINCIBLE
    function finInvicible() {
        invincibleOn = false;
        console.log("Peut se faire touché");
    }

    // ANIMATION - FRAME D'INVINCIBILITE

        // ANIMATION - FRAME D'INVINCIBILITE (PART 1 - INVISIBLE)
        function playerInvisible() {
            player.visible = false;
            setTimeout(playerVisible, 100);
        }

        // ANIMATION - FRAME D'INVINCIBILITE (PART 2 - VISIBLE)
        function playerVisible() {
            if (frameInvincible < 3) {
                console.log("visible");
                player.visible = true;
                setTimeout(playerInvisible, 100);   
                frameInvincible += 1;
            }
            else {
                player.visible = true;
                frameInvincible = 0;
            }
        }

// MORT DU JOUEUR
function killPlayer(){
    gameOver = true;
    player.setTint(0xff0000);
    player.anims.play('turn');
    this.physics.pause();
    lifeUI.setTexture('lifeDead');
    console.log("Check death 1");
}

// RESTART LE JEU
/*function respawn(){
    if (gameOver == true){

        setTimeout(function() {
            
            this.scene.restart();
            // VARIABLES
            let platforms;
            let player;
            let espritsLayer;

            let cursors;

            let health = 4;
            let frameInvincible = 0;
            let invincibleOn = false;

            let gameOver = false;

            let commandesLocked = false;
            let wallJumpLocked = false;

            let esprits;
            let textScore;
            let espritScore = 0;

            let speedMoveX = 200;
            let speedMoveY = 2000;
            let playerInertie = 0;

            let wallNeige = false;

            let doubleJumpAbility = false;
            let didPressJump = false;
            let canDoubleJump = false;

            var controller = false; //manette
        }, 1000);*/


        /*setTimeout(player.body.reset(1352, 680), 8000);

        setTimeout(function() {
            player.body.reset(1352, 680);    
            player.setTint(000000);
            
            health = 4;
            frameInvincible = 0;

            commandesLocked = false;
            wallJumpLocked = false;

            espritScore = 0;
        }, 1000);

    }
}*/
        </script>
    </body>
</html>